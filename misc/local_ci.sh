#!/usr/bin/env bash
# Local CI — mirrors GitHub Actions test.yml
#
# Runs the same checks as the CI pipeline but on local machine.
# Install as pre-push hook:  ./misc/local_ci.sh --install
#
# Usage:
#   ./misc/local_ci.sh              # Run all checks
#   ./misc/local_ci.sh --quick      # Syntax + lint only (fast, ~5s)
#   ./misc/local_ci.sh --unit       # Syntax + lint + unit tests
#   ./misc/local_ci.sh --full       # Everything including integration + CLI
#   ./misc/local_ci.sh --install    # Install as git pre-push hook
#   ./misc/local_ci.sh --uninstall  # Remove pre-push hook

set -euo pipefail

# ── Colors ────────────────────────────────────────────────────────────────────
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m'

# ── Config ────────────────────────────────────────────────────────────────────
REPO_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$REPO_ROOT"

FAILED=0
SKIPPED=0
TOTAL=0
RESULTS=()

# ── Helpers ───────────────────────────────────────────────────────────────────

step() {
    TOTAL=$((TOTAL + 1))
    printf "${BLUE}[%d] %s${NC} " "$TOTAL" "$1"
}

pass() {
    printf "${GREEN}✓${NC} (%.1fs)\n" "$1"
    RESULTS+=("${GREEN}✓${NC} $2")
}

fail() {
    printf "${RED}✗${NC} (%.1fs)\n" "$1"
    RESULTS+=("${RED}✗${NC} $2")
    FAILED=$((FAILED + 1))
}

skip() {
    printf "${YELLOW}⊘ skipped${NC}\n"
    RESULTS+=("${YELLOW}⊘${NC} $1 (skipped)")
    SKIPPED=$((SKIPPED + 1))
}

run_step() {
    # run_step "description" command [args...]
    local desc="$1"
    shift
    step "$desc"
    local start=$SECONDS
    if "$@" > /tmp/local_ci_output.log 2>&1; then
        pass "$(( SECONDS - start ))" "$desc"
        return 0
    else
        fail "$(( SECONDS - start ))" "$desc"
        # Show last 30 lines of output on failure
        echo ""
        printf "${RED}── Output (last 30 lines) ──${NC}\n"
        tail -30 /tmp/local_ci_output.log
        printf "${RED}────────────────────────────${NC}\n"
        echo ""
        return 1
    fi
}

# ── Install/Uninstall ─────────────────────────────────────────────────────────

install_hook() {
    local hook="$REPO_ROOT/.git/hooks/pre-push"
    cat > "$hook" << 'HOOK'
#!/usr/bin/env bash
# Auto-generated by misc/local_ci.sh --install
# Runs local CI before each push. Delete this file to disable.

REPO_ROOT="$(git rev-parse --show-toplevel)"

# Check if only non-code files changed (skip CI for docs/IDUN changes)
changed_files=$(git diff --name-only @{upstream}..HEAD 2>/dev/null || git diff --name-only HEAD~1..HEAD 2>/dev/null || echo "")
code_changed=false
while IFS= read -r f; do
    case "$f" in
        IDUN/*|*.md|docs/*|.gitignore|LICENSE) ;;
        *) code_changed=true; break ;;
    esac
done <<< "$changed_files"

if [ "$code_changed" = false ] && [ -n "$changed_files" ]; then
    echo "pre-push: only non-code files changed, skipping CI"
    exit 0
fi

echo "pre-push: running local CI (use --no-verify to skip)"
"$REPO_ROOT/misc/local_ci.sh" --unit
HOOK
    chmod +x "$hook"
    printf "${GREEN}Installed pre-push hook${NC} → .git/hooks/pre-push\n"
    printf "  Runs syntax + lint + unit tests before each push.\n"
    printf "  Push without checks: ${BOLD}git push --no-verify${NC}\n"
    exit 0
}

uninstall_hook() {
    local hook="$REPO_ROOT/.git/hooks/pre-push"
    if [ -f "$hook" ]; then
        rm "$hook"
        printf "${GREEN}Removed pre-push hook${NC}\n"
    else
        printf "${YELLOW}No pre-push hook found${NC}\n"
    fi
    exit 0
}

# ── Parse args ────────────────────────────────────────────────────────────────

MODE="default"  # default = syntax + lint + unit tests (same as --unit)
for arg in "$@"; do
    case "$arg" in
        --quick)     MODE="quick" ;;
        --unit)      MODE="unit" ;;
        --full)      MODE="full" ;;
        --install)   install_hook ;;
        --uninstall) uninstall_hook ;;
        --help|-h)
            echo "Usage: $0 [--quick|--unit|--full|--install|--uninstall]"
            echo ""
            echo "  --quick      Syntax + lint only (~5s)"
            echo "  --unit       Syntax + lint + unit tests (~30s) [default]"
            echo "  --full       All checks including integration + CLI (~2min)"
            echo "  --install    Install as git pre-push hook"
            echo "  --uninstall  Remove pre-push hook"
            exit 0
            ;;
        *)
            echo "Unknown option: $arg (use --help)"
            exit 1
            ;;
    esac
done

# ── Banner ────────────────────────────────────────────────────────────────────
echo ""
printf "${BOLD}═══════════════════════════════════════════════${NC}\n"
printf "${BOLD}  Local CI  [mode: %s]${NC}\n" "$MODE"
printf "${BOLD}═══════════════════════════════════════════════${NC}\n"
echo ""

START_TIME=$SECONDS

# ══════════════════════════════════════════════════════════════════════════════
# Phase 1: Syntax check (always runs)
# ══════════════════════════════════════════════════════════════════════════════

step "Syntax check (py_compile)"
start=$SECONDS
syntax_ok=true
while IFS= read -r -d '' f; do
    if ! python3 -m py_compile "$f" 2>/tmp/local_ci_output.log; then
        if [ "$syntax_ok" = true ]; then
            printf "${RED}✗${NC}\n"
            syntax_ok=false
        fi
        printf "  ${RED}FAIL${NC}: %s\n" "$f"
        cat /tmp/local_ci_output.log
    fi
done < <(find src/medgen -name '*.py' -print0)

if [ "$syntax_ok" = true ]; then
    pass "$(( SECONDS - start ))" "Syntax check"
else
    RESULTS+=("${RED}✗${NC} Syntax check")
    FAILED=$((FAILED + 1))
fi

# ══════════════════════════════════════════════════════════════════════════════
# Phase 2: Lint (always runs)
# ══════════════════════════════════════════════════════════════════════════════

run_step "Ruff lint" python -m ruff check src/medgen/ || true

# ══════════════════════════════════════════════════════════════════════════════
# Phase 3: Type check
# ══════════════════════════════════════════════════════════════════════════════

if [ "$MODE" != "quick" ]; then
    if command -v mypy &>/dev/null; then
        run_step "mypy type check" python -m mypy src/medgen/diffusion/ src/medgen/core/validation.py || true
    else
        step "mypy type check"
        skip "mypy type check"
    fi
fi

# ══════════════════════════════════════════════════════════════════════════════
# Phase 4: Unit tests
# ══════════════════════════════════════════════════════════════════════════════

if [ "$MODE" = "unit" ] || [ "$MODE" = "default" ] || [ "$MODE" = "full" ]; then
    run_step "Unit tests" python -m pytest tests/unit -m "not slow and not nightly" \
        --tb=short -q --no-header || true
fi

# ══════════════════════════════════════════════════════════════════════════════
# Phase 5: Integration + CLI tests (--full only)
# ══════════════════════════════════════════════════════════════════════════════

if [ "$MODE" = "full" ]; then
    run_step "Integration tests" python -m pytest tests/integration \
        -m "not slow and not gpu and not baseline" \
        --tb=short -q --no-header --timeout=60 || true

    if [ -f "tests/e2e/test_cli_complete.py" ]; then
        run_step "CLI tests" python -m pytest tests/e2e/test_cli_complete.py \
            --tb=short -q --no-header --timeout=120 || true
    fi
fi

# ══════════════════════════════════════════════════════════════════════════════
# Summary
# ══════════════════════════════════════════════════════════════════════════════

ELAPSED=$((SECONDS - START_TIME))
echo ""
printf "${BOLD}───────────────────────────────────────────────${NC}\n"
printf "${BOLD}  Results  (${ELAPSED}s)${NC}\n"
printf "${BOLD}───────────────────────────────────────────────${NC}\n"
for r in "${RESULTS[@]}"; do
    printf "  %b\n" "$r"
done
echo ""

if [ "$FAILED" -gt 0 ]; then
    printf "${RED}${BOLD}  %d/%d checks failed${NC}\n\n" "$FAILED" "$TOTAL"
    exit 1
else
    PASSED=$((TOTAL - SKIPPED))
    printf "${GREEN}${BOLD}  All %d checks passed" "$PASSED"
    if [ "$SKIPPED" -gt 0 ]; then
        printf " (%d skipped)" "$SKIPPED"
    fi
    printf "${NC}\n\n"
    exit 0
fi
